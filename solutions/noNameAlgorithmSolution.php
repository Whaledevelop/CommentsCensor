<?php
  /**
   * Функция подготавливает массив $lettersArrays, нужный для поиска.
   * Это двумерный массив, состоящий из массивов, в каждом из которых
   * записаны все символы с одинаковой позицией в разных паттернах. 
  */
  function getLettersArraysOfPatterns(array $patterns) : array {
    $lettersArrays = []; 

    $patternsLengths = array_map("strlen", $patterns);
    rsort($patternsLengths);
    $max_length = $patternsLengths[0];

    foreach ($patterns as $pattern) {
      for ($i = 0; $i < $max_length; $i++) {
        $lettersArrays[$i][] = empty($pattern[$i]) 
          // пустая строка добавляется для того, зарезервировать место, чтобы
          // массивы второго уровня имели одинаковое количество элементов
          // (чтобы более длинный паттерн не съезжал на k индекс более короткого)
          ? ""  
          : $pattern[$i];
      }    
    }
    return $lettersArrays;
  }

  /**
   * Изначально идея алгоритма возникла из желания объединить поиск по 
   * нескольким паттернам. Я представлял его похожим на наивный алгоритм,
   * но в процессе реализации все изменилось. В нем есть возможность 
   * сдвига на несколько символов, как в алгоритме КМП в случае частичного
   * совпадения, но вместо префикс функции используется массив с символами
   * по позициям, который позволяет работать с несколькими паттернами.
   */
  function noNameAlgorithmSolution(string $string, array $patterns) {
    $lettersArrays = getLettersArraysOfPatterns($patterns);
    // j - индекс массива символов определенной позиции
    // Индекс массива первого уровня массива $lettersArrays
    $j = 0;
    // k - индекс символа в подстроке среди символов других паттернов
    // Индекс массива второго уровня массива $lettersArrays
    $k = 0;
    // i - индекс рассматриваемого символа строки
    $i = 0;
    while($i < strlen($string)) {
      // $lettersArrays[$j][$k] - это $j-ый символ $k паттерна 
      if (strtolower($string[$i]) === $lettersArrays[$j][$k]) {
        // В случае совпадения проверяем следующий символ из строки с 
        // следующим символом того паттерна, которому принадлежит совпавший символ
        $i++;
        $j++;
      } else {
        // Если j равно нулю и совпадение не найдено, это значит, что предыдущее
        // сравнение символов тоже было отрицательным.
        if ($j === 0) {
          // Если проверяемый символ - последний среди символов этой позиции паттернов,
          // то совпадение не найдено ни в одном паттерну, переходим к следующему
          // символу, поиск совпадений по нему начинаем с первого символа паттернов
          // Если нет, то проверяемый следующий паттерн
          if ($k === count($lettersArrays[$j]) - 1) {
            $k = 0;
            $i++;
          } else {
            $k++;
          }
        } else {
          // Совпадение найдено, если $j прошел по всей длине массива, т.е. проверил
          // все символы. Если паттерн максимальной длины по отношению к другим паттернам,
          // то $j будет равен массиву символов, если нет, то для в $k элементе массива
          // массива с индексом $j будет пустое значение. Эти пустые значения добавляются
          // в функции создания массива для того, чтобы паттерны большей длины не занимали 
          // $k индексы других паттернов.
          if ($lettersArrays[$j][$k] === "" || $j === count($lettersArrays)) {
            $string = substr_replace($string, "*", $i - $j, $j);
            // в случае нахождения совпадения переходим в конец совпадения, продолжаем поиск
            // новых совпадений
            $i = $j;
            $j = 0;
            $k = 0;            
          } else {
            // Если j не равен нулю и совпадение не найдено, но значит
            // символы предшествующие рассматриваемому совпали. Тогда мы хотим
            // вернуться к тому i индексу, с которого началась "успешная серия"
            // Для этого используется индекс $j. Дальнейшее поведение зависит от того,
            // были ли рассмотрены все символы всех паттернов. Если все, то 
            // к $i прибавляется еще +1, т.к. мы переходим к следующему после запомненного
            if ($k === count($lettersArrays[$j]) - 1) {
              $i = $i - $j + 1;
              $j = 0;
              $k = 0;
            } else {
              $i = $i - $j;
              $j = 0;
              $k++;
            }
          }
        }
      }
    }
    return $string;  
  }
?>